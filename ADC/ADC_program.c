/*
 * ADC_program.c
 *
 *  Created on: Mar 17, 2022
 *      Author: MyComputer
 */

#include "std_types.h"
#include "BIT_MATH.h"


#include "Dio_interface.h"
#include "Dio_reg.h"

#include "ADC_reg.h"
#include "ADC_interface.h"
#include "ADC_config.h"
void ADC_Init()
{
	DIO_voidSetPinDirection(DIO_u8PORT_A,DIO_u8PIN_0,DIO_u8INPUT);

	SET_BIT(ADCSRA,ADCSRA_ADEN); //ADC enable//
	//SET_BIT(ADCSRA,ADC_INTE);


	//DIO_voidSetPortValue(DIO_u8PORT_A, Input);
	/*Choose reference voltage*/
#if(VREF == EXTERNAL_VCC_CAP )
	SET_BIT(ADMUX,ADMUX_REFS0);
	CLR_BIT(ADMUX,ADMUX_REFS1);
#elif(VREF == INTERNAL_VREF_OFF)
	CLR_BIT(ADMUX,ADMUX_REFS0);
	CLR_BIT(ADMUX,ADMUX_REFS1);
#elif(VREF == INT256_CAP_ON_ARFF)
	SET_BIT(ADMUX,ADMUX_REFS0);
	SET_BIT(ADMUX,ADMUX_REFS1);
#endif

	/*choose prescaler*/
#if(PRESCALER == PRESCALER_2)
	SET_BIT(ADCSRA,ADCSRA_ADPS0);
	CLR_BIT(ADCSRA,ADCSRA_ADPS1);
	CLR_BIT(ADCSRA,ADCSRA_ADPS2);
#elif(PRESCALER == PRESCALER_4)
	CLR_BIT(ADCSRA,ADCSRA_ADPS0);
	SET_BIT(ADCSRA,ADCSRA_ADPS1);
	CLR_BIT(ADCSRA,ADCSRA_ADPS2);
#elif(PRESCALER == PRESCALER_8)
	SET_BIT(ADCSRA,ADCSRA_ADPS0);
	SET_BIT(ADCSRA,ADCSRA_ADPS1);
	CLR_BIT(ADCSRA,ADCSRA_ADPS2);
#elif(PRESCALER == PRESCALER_16)
	CLR_BIT(ADCSRA,ADCSRA_ADPS0);
	CLR_BIT(ADCSRA,ADCSRA_ADPS1);
	SET_BIT(ADCSRA,ADCSRA_ADPS2);
#elif(PRESCALER == PRESCALER_32)
	SET_BIT(ADCSRA,ADCSRA_ADPS0);
	CLR_BIT(ADCSRA,ADCSRA_ADPS1);
	SET_BIT(ADCSRA,ADCSRA_ADPS2);
#elif(PRESCALER == PRESCALER_64)
	CLR_BIT(ADCSRA,ADCSRA_ADPS0);
	SET_BIT(ADCSRA,ADCSRA_ADPS1);
	SET_BIT(ADCSRA,ADCSRA_ADPS2);
#elif(PRESCALER == PRESCALER_128)
	SET_BIT(ADCSRA,ADCSRA_ADPS0);
	SET_BIT(ADCSRA,ADCSRA_ADPS1);
	SET_BIT(ADCSRA,ADCSRA_ADPS2);
#endif

	//*Data adjustment in register*//
#if(ADJUST == RIGHT_ADJUST)
	CLR_BIT(ADMUX,ADMUX_ADLAR);
#elif(ADJUST == LEFT_ADJUST)
	SET_BIT(ADMUX,ADMUX_ADLAR);
#endif


}
static void Start_Conversion(void)
{
	SET_BIT(ADCSRA,ADCSRA_ADSC);

}
u16 ADC_ReadChannel(u8 Copy_Channel)
{
u16 Local_Data = 0;
//*choose Channel*//
#if(CHANNEL == CHANNEL_0)
	CLR_BIT(ADMUX, ADMUX_MUX0);
	CLR_BIT(ADMUX, ADMUX_MUX1);
	CLR_BIT(ADMUX, ADMUX_MUX2);
	CLR_BIT(ADMUX, ADMUX_MUX3);
	CLR_BIT(ADMUX, ADMUX_MUX4);
#elif(CHANNEL == CHANNEL_1)
	SET_BIT(ADMUX, ADMUX_MUX0);
	CLR_BIT(ADMUX, ADMUX_MUX1);
	CLR_BIT(ADMUX, ADMUX_MUX2);
	CLR_BIT(ADMUX, ADMUX_MUX3);
	CLR_BIT(ADMUX, ADMUX_MUX4);
#elif(CHANNEL == CHANNEL_2)
	CLR_BIT(ADMUX, ADMUX_MUX0);
	SET_BIT(ADMUX, ADMUX_MUX1);
	CLR_BIT(ADMUX, ADMUX_MUX2);
	CLR_BIT(ADMUX, ADMUX_MUX3);
	CLR_BIT(ADMUX, ADMUX_MUX4);
#elif(CHANNEL == CHANNEL_3)
	SET_BIT(ADMUX, ADMUX_MUX0);
	SET_BIT(ADMUX, ADMUX_MUX1);
	CLR_BIT(ADMUX, ADMUX_MUX2);
	CLR_BIT(ADMUX, ADMUX_MUX3);
	CLR_BIT(ADMUX, ADMUX_MUX4);
#elif(CHANNEL == CHANNEL_4)
	CLR_BIT(ADMUX, ADMUX_MUX0);
	CLR_BIT(ADMUX, ADMUX_MUX1);
	SET_BIT(ADMUX, ADMUX_MUX2);
	CLR_BIT(ADMUX, ADMUX_MUX3);
	CLR_BIT(ADMUX, ADMUX_MUX4);
#elif(CHANNEL == CHANNEL_5)
	SET_BIT(ADMUX, ADMUX_MUX0);
	CLR_BIT(ADMUX, ADMUX_MUX1);
	SET_BIT(ADMUX, ADMUX_MUX2);
	CLR_BIT(ADMUX, ADMUX_MUX3);
	CLR_BIT(ADMUX, ADMUX_MUX4);
#elif(CHANNEL == CHANNEL_6)
	CLR_BIT(ADMUX, ADMUX_MUX0);
	SET_BIT(ADMUX, ADMUX_MUX1);
	SET_BIT(ADMUX, ADMUX_MUX2);
	CLR_BIT(ADMUX, ADMUX_MUX3);
	CLR_BIT(ADMUX, ADMUX_MUX4);
#elif(CHANNEL == CHANNEL_7)
	SET_BIT(ADMUX, ADMUX_MUX0);
	SET_BIT(ADMUX, ADMUX_MUX1);
	SET_BIT(ADMUX, ADMUX_MUX2);
	CLR_BIT(ADMUX, ADMUX_MUX3);
	CLR_BIT(ADMUX, ADMUX_MUX4);
#endif
	//*start conversion *//
Start_Conversion();

//while(GET_BIT(ADCSRA,ADCSRA_ADIF)==0); //not sure of this step
//SET_BIT(ADCSRA,ADCSRA_ADIF);

if(ADJUST == 0)
{
	Local_Data = ADCL_H;
}
else
{
	Local_Data = ADCL_H>>6; // i don't know why this step this like left adjustment
}
return Local_Data ;

}
